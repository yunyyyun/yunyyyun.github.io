## iOS绘图的几种方式

先看一张图:

![](/img/02-12.png)

图中表明了iOS中常见的三种绘图方式：

* OpenGL ES
* Core Graphics
* Core Animation

```这里暂不提及 mental```

其中OpenGL ES和Core Graphics都是偏底层的框架，关于OpenGL的使用可参考我的一个例子：

https://github.com/yunyyyun/Magic

下面简单记录下Core Graphics 和 Core Animation

#### Core Animation

Core Animation是一个图形渲染和动画的基础库，是一个复合引擎，职责就是尽可能快地组合屏幕上不同的可视内容，这个内容是被分解成独立的图层，存储在一个叫图层树的体系之中。关于Core Animation有以下几个特点

Core Animation可以直接用在Max OS X和IOS平台上。
Core Animation的动画执行过程都是在后台操作的，不会阻塞主线程（异步绘制）。
Core Animation是直接作用于CALayer，并非直接作用于UIView。

另外，Core Animation是基于QuartzCore的,你可以在*CoreAnimation.h*中看到对QuartzCore的import

##### CoreAnimation使用：

似乎大多数绘图的api都有一个上下文 context，一个context可以理解成一个画板，一个绘图的步骤就是对画板的操作，例如下面为画线的过程：

```
		//初始化一个线的图层
    CAShapeLayer *lineLayer = [CAShapeLayer layer];
    [self.layer addSublayer: lineLayer];
    //初始化一个描述的路径
    UIBezierPath *linePath = [UIBezierPath bezierPath];
    //设置线段开始的点
    [linePath moveToPoint:beginPoint];
    //设置线段结束的点
    //这里也可以添加多个点
    [linePath addLineToPoint:endPoint];
    //设置图层路径
    lineLayer.path = linePath.CGPath;
    //设置图层的其他属性
    lineLayer.lineWidth = lineWidth;
    lineLayer.strokeColor = lineColor.CGColor;
    lineLayer.fillColor = [UIColor clearColor].CGColor;
```

#### Core Graphics的使用

```
CGContextRef ctx = UIGraphicsGetCurrentContext();

[_lineColor setStroke];
CGContextSetLineWidth(ctx, _lineWidth);

CGContextMoveToPoint(ctx, start.x, start.y);
CGContextAddLineToPoint(ctx, end.x, end.y);

CGContextStrokePath(ctx);

```

整体来说包括这几个步骤：

* 获取图文上下文， 即context
* 设置绘图属性，这些属性包括颜色、size、虚线、渐变等
* 绘制图元，图元包括点、线、矩形、椭圆等
* 设置填充，填充包括2种*CGContextStrokePath* 表示只绘制线条，*CGContextFillPath*则是填充闭合的path（圆、矩形）

当然还有其它一些比较好用的api，例如

```
CGContextSaveGState(ctx); 暂存当前context的配置
CGContextRestoreGState(ctx); 恢复上一次保存的配置
```

#### 个人总结

一般来说，使用Core Animation的意思是指使用CAShapeLayer结合UIBezierPath， 即直接在layer上绘图，其好处有：

* CAShapeLayer渲染更快速。因为它使用了硬件加速，绘制同一图形会比用Core Graphics快很多。

* CAShapeLayer更高效使用内存。一个CAShapeLayer不需要像普通CALayer一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存。

* CAShapeLayer不会被图层边界剪裁掉，一个 CAShapeLayer 可以在边界之外绘制。你的图层路径不会像在使用 Core Graphics 的普通 CALayer 一样被剪裁掉。

* CAShapeLayer不会出现像素化。当你给 CAShapeLayer 做3D变换时，它不像一个有寄宿图的普通图层一样变得像素化。

而具体绘制图形，一般有两种方式：UIBezierPath 和使用 CGContextRef。CGContextRef是基于UIView(但是实际上也是画在CALayer上的)，大约有如下需要注意的：

* [内存暴涨问题](https://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=447105405&idx=1&sn=054dc54289a98e8a39f2b9386f4f620e&scene=23&srcid=0108RhyzhXk9wUwQvnW3cmZT#rd)

* 渲染速度，正如前文所述，CAShapeLayer渲染更快速。因为它使用了硬件加速，CALayer则没有
* 像素画等问题

```
我们一般在UIView上绘图的时候可以继承UIView并重写draw(_ rect: CGRect)方法，在这个方法里边取的上下文进行自定义的绘制。如果重写了这个方法，UIView 就会创建一个寄宿图，大小是 UIView的 width * height * 屏幕scale，如果是在比较大的区域绘制，不建议用这种方式，这种方式会造成内存暴涨。可以通过专用图层来解决这个问题，后边会说道这个问题。
```

### 关于K线绘制选择

实际上K使用Core Graphics或Core Animation，很多公司实用的也是Core Graphics，只要绘图size不要太大也不会出现内存暴涨问题（不然这些大厂早就改了）。当然最佳选择应该还是用Core Animation，即CAShapeLayer+UIBezierPath的方式。至于两种方式差别有多大，还需要实际的验证。